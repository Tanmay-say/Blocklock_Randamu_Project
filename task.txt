Awesome‚Äîhere‚Äôs a **copy-paste ‚ÄúCursor prompt‚Äù** that will get you a production-grade backend (contracts + server workers) for your **Sealed-Bid Soul NFT Auction** powered by **Blocklock** (timelocked encryption) and **Randamu Verifiable Randomness**, plus a **Winner SBT (ERC-5192)**.

> Paste everything between the lines into a new Cursor task.

---

### üöÄ Cursor Prompt ‚Äî Backend (Solidity + Node + Hardhat)

**Goal:** Build a sealed-bid NFT auction backend where bid amounts are **encrypted off-chain** with **Blocklock** and only decryptable **at/after `endBlock`**. Use **Randamu Verifiable Randomness** for tie-breaks. Mint a **Winner SBT (ERC-5192)** as a soulbound ‚Äúwinner badge‚Äù.
References: Blocklock quickstart & client guides (dcipher network) ([docs.dcipher.network][1]), blocklock-js repo (API/shape) ([GitHub][2]), Randamu randomness quickstart ([docs.dcipher.network][3]), ERC-5192 spec ([Ethereum Improvement Proposals][4]).

#### Tech choices

* EVM toolchain: **Hardhat** (TypeScript), **OpenZeppelin** for ERC-721/AccessControl, **ERC-5192** for Winner SBT.
* Contracts: `AuctionHouse.sol`, `WinnerSBT.sol`, `TestNFT.sol` (for local testing), `RandamuVRFConsumer.sol` (or integrate directly in AuctionHouse).
* SDKs: **blocklock-js** (front/server for encryption helpers) and **randamu randomness solidity** per quickstart. ([GitHub][2], [docs.dcipher.network][3])
* Chains: default **Base Sepolia** (or any EVM testnet supported by dcipher).

---

## 1) Repository layout

```
/contracts
  AuctionHouse.sol
  WinnerSBT.sol
  TestNFT.sol
  interfaces/IBlocklockReceiver.sol   // callback interface if needed by quickstart
  libs/Errors.sol
  libs/Structs.sol
  RandamuVRFConsumer.sol              // if separate
/scripts
  deploy.ts
  seed.ts
  finalize-auction.ts                 // settlement script / keeper
/task-bots
  settlementBot.ts                    // off-chain helper to pull decrypted bids if workflow requires
/test
  AuctionHouse.spec.ts
  WinnerSBT.spec.ts
hardhat.config.ts
.env.example
package.json
README.md
```

---

## 2) Core features & flows

**Auction creation**

* `createAuction(nft, tokenId, reserve, endBlock, depositPctBasis)` (admin/seller).
* Escrow NFT into contract.

**Bid commit (sealed)**

* Frontend/server uses **blocklock-js** to encrypt `{amount, bidder, auctionId, nonce}` with condition `endBlock`. Store `ciphertext` + `conditionBytes` on-chain via:

  * `commitBid(auctionId, bytes ciphertext, bytes condition, address refundTo)` (payable: `deposit = max(reserve, minDeposit)` or percent of declared bid‚Äîuse fixed percent to avoid info leaks).
* Contract only stores ciphertext & a blinded hash for indexing; **no plaintext**.

**Reveal / Decrypt**

* After `endBlock`, the dcipher/Blocklock condition is met and key material becomes available (per quickstart). Contract (or a bot) calls the registered callback or pulls completed payload, then:

  * `processDecryptedBid(auctionId, bidder, uint256 revealedAmount)` ‚Äî validate authenticity (match ciphertext ‚Üî revealed), update highest.

**Finalize**

* `finalize(auctionId)` (after `endBlock` and decrypt window).
* If tie on top bids, request **Randamu VRF**; on `fulfillRandomness`, select winner deterministically among ties. ([docs.dcipher.network][3])
* Transfer NFT to winner; charge winner (deposit applied) and **refund all losers**.
* Mint **Winner SBT (ERC-5192)** to winner with metadata (auctionId, nftAddress, tokenId). ([Ethereum Improvement Proposals][4])

**Admin views** (for your UI)

* Read-only getters for auctions, encrypted bids, deposit pool, status, winner, SBT id, etc.

---

## 3) Contract specs (high-level)

**`AuctionHouse.sol`**

* Roles: `DEFAULT_ADMIN_ROLE`, `SELLER_ROLE` (optional).
* Structs:

  * `Auction { address nft; uint256 tokenId; uint96 reserve; uint64 endBlock; uint16 depositPct; address seller; bool settled; address winner; uint256 winningBid; }`
  * `EncryptedBid { bytes32 id; address bidder; bytes ciphertext; bytes condition; uint96 deposit; bool processed; uint256 revealedAmount; }`
* Events:

  * `AuctionCreated(...)`, `BidCommitted(auctionId, bidder, bidId)`, `BidRevealed(auctionId, bidder, amount)`, `RandomnessRequested(auctionId, requestId)`, `Finalized(auctionId, winner, amount)`.
* Functions:

  * `createAuction(...)`
  * `commitBid(auctionId, bytes calldata ciphertext, bytes calldata condition, address refundTo) external payable`
  * **Blocklock callback** (shape per quickstart): e.g., `onBlocklockDecryption(bytes calldata payload)` or `completeBid(auctionId, bidder, amount, proof)` depending on docs. Wire per guide. ([docs.dcipher.network][1])
  * `requestTieBreakRandomness(auctionId)` & `fulfillRandomness(...)` per Randamu quickstart. ([docs.dcipher.network][3])
  * `finalize(auctionId)`
  * View helpers (for admin panel).

**`WinnerSBT.sol`**

* Minimal **ERC-5192** (non-transferable) with `mintLocked(address to, uint256 auctionId)` and `tokenURI`. Implement `locked(uint256)` returning `true`. ([Ethereum Improvement Proposals][4])

**`TestNFT.sol`**

* Simple ERC-721 mintable for local testing.

---

## 4) Off-chain helpers

**Settlement bot (`task-bots/settlementBot.ts`)**

* Watches for `endBlock` & decryption-ready events.
* If Blocklock quickstart uses an off-chain fetch-and-submit of decrypted payloads, the bot calls `processDecryptedBid` for each bid, then calls `finalize`. (Follow dcipher client guide.) ([docs.dcipher.network][5])

---

## 5) Hardhat + dependencies

**Install**

```bash
npm i -D hardhat typescript ts-node @types/node chai @types/chai mocha @types/mocha ethers @nomicfoundation/hardhat-toolbox
npm i @openzeppelin/contracts
# if provided as npm: randamu randomness solidity (follow quickstart); else vendor per docs
```

**Env**

```
RPC_URL=<base_sepolia_or_choice>
PRIVATE_KEY=<deployer>
RANDAMU_*=...(per randomness quickstart)
```

**hardhat.config.ts**

* Configure networks, etherscan (optional), compiler 0.8.24+, and paths.

**Scripts**

* `deploy.ts`: deploy TestNFT ‚Üí AuctionHouse ‚Üí WinnerSBT; set references.
* `seed.ts`: mint demo NFT, approve, create auction (reserve, endBlock \~ +N blocks).
* `finalize-auction.ts`: run finalize; handle refunds.

---

## 6) Security/Design notes

* **No bid leaks:** store only ciphertext & constant-percent deposit (not dependent on amount) to reduce inference.
* **Replay protection:** include `chainId`, `auctionId`, and a `nonce` inside the encrypted blob.
* **Time source:** rely on **block height** (not timestamps) to align with Blocklock condition. ([docs.dcipher.network][1])
* **Randomness:** document tie-break using Randamu library per quickstart (or stub Chainlink VRF v2.5 as alternative if network lacks support). ([docs.dcipher.network][3], [Chainlink Documentation][6])
* **SBT risks:** soulbound means non-transferable; follow ERC-5192 minimal interface. ([Ethereum Improvement Proposals][4])

---

## 7) What to generate now (acceptance criteria)

1. **Contracts code** for:

   * `AuctionHouse.sol` implementing flows above + hooks for Blocklock decrypt completion.
   * `WinnerSBT.sol` implementing ERC-5192.
   * `TestNFT.sol` for local tests.
2. **Interfaces** for Blocklock callback per dcipher quickstart (client/contract shape). ([docs.dcipher.network][1])
3. **Randamu randomness integration** stubs + full implementation of request/fulfill for tie cases. ([docs.dcipher.network][3])
4. **Deploy scripts** (`scripts/deploy.ts`, `scripts/seed.ts`) and **settlement script**.
5. **Unit tests** covering: create ‚Üí commit sealed bids ‚Üí simulate decrypt callback ‚Üí finalize (win, refunds, SBT mint) ‚Üí tie-break via randomness.
6. **README** with:

   * How to run local node, deploy, seed an auction, simulate endBlock, call finalize.
   * How to configure dcipher/Blocklock & randomness per docs (link to guides). ([docs.dcipher.network][1])

Use clean, commented code and emit events for every critical step.

---

### Notes for implementer (Cursor):

* Follow **dcipher Blocklock Quickstart** patterns for Solidity callback & request wiring (names may differ‚Äîmirror exactly from docs). ([docs.dcipher.network][1])
* For the **client/server encryption step**, include a tiny Node utility using **blocklock-js** that produces `{ciphertext, condition}` for tests. ([GitHub][2], [docs.dcipher.network][5])
* Implement **ERC-5192** exactly per spec (immutable locked). ([Ethereum Improvement Proposals][4])
* Implement **Randamu randomness** per quickstart (request ‚Üí fulfill), guard finalize until randomness is delivered when ties exist. ([docs.dcipher.network][3])
* Provide mock/fallback randomness for local unit tests if needed.

---

**Source refs:**
Blocklock quickstarts & client guide (dcipher) ([docs.dcipher.network][1]) ¬∑ blocklock-js repo ([GitHub][2]) ¬∑ Randamu randomness quickstart ([docs.dcipher.network][3]) ¬∑ ERC-5192 spec ([Ethereum Improvement Proposals][4]) ¬∑ (Alt) Chainlink VRF docs for reference ([Chainlink Documentation][6])

---

If you want, I can now generate the **actual contract code** and scripts to drop straight into your repo.

[1]: https://docs.dcipher.network/category/quickstart?utm_source=chatgpt.com "Quickstart | dcipher network docs"
[2]: https://github.com/randa-mu/blocklock-js?utm_source=chatgpt.com "randa-mu/blocklock-js - GitHub"
[3]: https://docs.dcipher.network/features/verifiable-randomness/quickstart?utm_source=chatgpt.com "Verifiable Randomness | dcipher network docs"
[4]: https://eips.ethereum.org/EIPS/eip-5192?utm_source=chatgpt.com "ERC-5192: Minimal Soulbound NFTs"
[5]: https://docs.dcipher.network/guides/blocklock/clientSideBlocklockRequest?utm_source=chatgpt.com "Client-side Blocklock Encryption | dcipher network docs"
[6]: https://docs.chain.link/vrf?utm_source=chatgpt.com "Chainlink VRF"
